
---------------------------------------------------------------------------------------------------
-- Functions                                                                                     --
---------------------------------------------------------------------------------------------------

define id          x := x
define compose g f x := g (f x)
define const     a x := a

define let e f := f e

define $ := compose

define combY := \f. (\x. f (x x)) (\x. f (x x))
define combZ := \f. (\x. f (\v. x x v)) (\x. f (\v. x x v))



---------------------------------------------------------------------------------------------------
-- Unit Type                                                                                     --
---------------------------------------------------------------------------------------------------

define unit     := \u. u

define recU a u := u a




---------------------------------------------------------------------------------------------------
-- Booleans                                                                                      --
---------------------------------------------------------------------------------------------------

define true  a b := a
define false a b := b

define recB x y b := b x y

define if      b t f := recB t f b
define not     x a b := x b a
define or      x y := x true y
define and     x y := x y false
define xor     x y := x (not y) y
define implies x y := x y true




---------------------------------------------------------------------------------------------------
-- Pairs                                                                                         --
---------------------------------------------------------------------------------------------------

define pair  a b := \s. s a b

define fst    p := p true
define snd    p := p false
define recP f p := f (fst p) (snd p)

define swap    p := pair (snd p) (fst p)
define apFst f p := pair (f (fst p)) (snd p)
define apSnd f p := pair (fst p) (f (snd p))
define ap  f g p := recP (\a b. pair (f a) (g b)) p




---------------------------------------------------------------------------------------------------
-- Sums                                                                                          --
---------------------------------------------------------------------------------------------------

define left  a := pair true a
define right b := pair false b

define recS f g s := recP (\z v. if z (f v) (g v)) s

define case    s f g := recS f g s
define isLeft  s     := case s (\z. true) (\z. false)
define isRight s     := case s (\z. false) (\z. true)




---------------------------------------------------------------------------------------------------
-- Natural Numbers                                                                               --
---------------------------------------------------------------------------------------------------

define 0      := \f x. x
define succ n := \f x. f (n f x)

define recN x f n := n f x

-- general recursion : c -> (n -> c -> c) -> n -> c
define genRecN c g n := snd (recN (pair 0 c) (\p. recP (\k v. pair (succ k) (g k v)) p) n)

define isZero := recN true (\u. false)
define isEven := recN true not
define isOdd  := recN false not

define pred  n := \f x. recN (\u. x) (\g h. h (g f)) n id
define pred2 n := \f x. snd (recN (left x) (\s. case s (\z. right z) (\z. right (f z))) n)

define iterate f n s := recN s f n

define 1 := succ 0
define 2 := succ 1
define 3 := succ 2
define 4 := succ 3
define 5 := succ 4
define 6 := succ 5
define 7 := succ 6
define 8 := succ 7
define 9 := succ 8

define + n m := recN m succ n
define * n m := recN 0 (+ m) n
define ^ n m := recN 1 (* n) m

define eqN n m := 
    if (isZero n) 
        (isZero m)
        (if (isZero m)
            false
            (recS
                (\k. false)
                (\b. b)
                (recN
                    (left m)
                    (\s. case s
                            (\k. let (pred k) (\k'. if (isZero k') (right true) (left k')))
                            (\b. right false))
                    n)))

define fib  n := fst (recN (pair 0 1) (\p. apSnd (+ (snd p)) (swap p)) n)
define fact n := fst (recN (pair 1 1) (\p. ap (* (snd p)) succ p) n)
define tri  n := genRecN 0 (\k l. + (succ k) l) n

define div2 n := recN (\b. 0) (\f b. if b (succ (f (not b))) (f (not b))) n false

define showNatBin digits n := 
    \0 1 bin. snd 
        (recN
            (pair n (if (isEven n) 
                        (\s. s 0) 
                        (\s. s 1))) 
            (\p. recP 
                (\k v. 
                    (\h. pair h (if (isEven h) 
                                    (\s. v (\a. s 0 a))
                                    (\s. v (\a. s 1 a))))
                    (div2 k))
                p)
            (pred digits))
        id




---------------------------------------------------------------------------------------------------
-- Lists                                                                                         --
---------------------------------------------------------------------------------------------------

define empty    := \g e. e
define cons a l := \g e. g a (l g e)

define singleton a := cons a empty

define [] := empty
define @  := cons
define {} := singleton

define recL  e g l := l g e
define foldr e g l := l g e

define isEmpty l := recL true (\a b. false) l
define head    l := recL unit (\a xs. a) l
define tail    l := snd (recL (pair id empty) (\a p. pair (cons a) (recP (\f l. f l) p)) l)
define last    l := recL id (\a f. compose f (const a)) l unit
define init    l := recL (\z h. empty) (\a f z h. h z (f a cons)) l unit false

define map    f   := recL empty (\a bs. cons (f a) bs)
define concat u v := recL v cons u
define join   ls  := recL empty concat ls

define ++ := concat

define prepend x l := concat l (singleton x)

define listNatAsc n := recN (singleton 0) (\xs. cons 0 (map succ xs)) n
define listNatDsc n := recN (singleton 0) (\xs. cons (succ (head xs)) xs) n

define listNatAscBad n := genRecN (singleton n) (\k l. cons (pred (head l)) l) n
define listNatDscBad n := genRecN (singleton 0) (\k l. cons (succ k) l) n

define showList l := 
    \[ , ] list.
        (recL 
            (\s. s ])
            (\a f s. f (s , a))
            l)
        (\s. [)




---------------------------------------------------------------------------------------------------
-- Algebraic Lists                                                                               --
---------------------------------------------------------------------------------------------------

define emptyA    := left unit
define consA a l := right (pair a l)

define headA l := case l (\u. emptyA) fst
define tailA l := case l (\u. emptyA) snd

-- Is this derivable for a general algebraic type?
define recAL_kappa := \a l u g. u a (g l u g) u g
define recAL_eta   := \x l u g. case l (\z. x) (\z. z recAL_kappa u g)
define recAL x f l := recAL_eta x l (\a l u g. f a l) (recAL_eta x)

define algListToList l  := recAL empty cons l
define listToAlgList al := recL emptyA consA al

define isEmptyA l := recAL true (\a b. false) l
define headA    l := recAL unit (\a xs. a) l
define tailA    l := snd (recAL (pair id emptyA) (\a p. pair (consA a) (recP (\f l. f l) p)) l)




---------------------------------------------------------------------------------------------------
-- Vectors                                                                                       --
---------------------------------------------------------------------------------------------------

-- vector constructor, takes n arguments
define vector n := recN (\g s. g (s n)) (\f g e. f (\x. g (x e))) n id

define extend v e := \s. v (\k. s (succ k) e)

define size v := v (\k. if (isZero k) 0 (recN (\x. k) (\f x. f) (pred k)))

define coord i v := 
    let (recP
            (\rest f. recN f (\g _. g) rest)
            (recN 
                (pair (size v) (\a. a)) 
                (\p. recP (\sz f. pair (pred sz) (\a _. f a)) p) (pred i)))
    \accessor.
        v accessor