
---------------------------------------------------------------------------------------------------
-- Functions                                                                                     --
---------------------------------------------------------------------------------------------------

define id          x := x
define compose g f x := g (f x)
define const     a x := a

define combY := \f. (\x. f (x x)) (\x. f (x x))
define combZ := \f. (\x. f (\v. x x v)) (\x. f (\v. x x v))



---------------------------------------------------------------------------------------------------
-- Unit Type                                                                                     --
---------------------------------------------------------------------------------------------------

define unit     := \u. u

define recU a u := u a




---------------------------------------------------------------------------------------------------
-- Booleans                                                                                      --
---------------------------------------------------------------------------------------------------

define true  a b := a
define false a b := b

define recB x y b := b x y

define if      b t f := recB t f b
define not     x a b := x b a
define or      x y := x true y
define and     x y := x y false
define xor     x y := x (not y) y
define implies x y := x y true




---------------------------------------------------------------------------------------------------
-- Pairs                                                                                         --
---------------------------------------------------------------------------------------------------

define pair  a b := \s. s a b

define fst    p := p true
define snd    p := p false
define recP f p := f (fst p) (snd p)

define swap    p := pair (snd p) (fst p)
define apFst f p := pair (f (fst p)) (snd p)
define apSnd f p := pair (fst p) (f (snd p))
define ap  f g p := recP (\a b. pair (f a) (g b)) p




---------------------------------------------------------------------------------------------------
-- Sums                                                                                          --
---------------------------------------------------------------------------------------------------

define left  a := pair true a
define right b := pair false b

define recS f g s := recP (\z v. if z (f v) (g v)) s

define case    s f g := recS f g s
define isLeft  s     := case s (\z. true) (\z. false)
define isRight s     := case s (\z. false) (\z. true)




---------------------------------------------------------------------------------------------------
-- Natural Numbers                                                                               --
---------------------------------------------------------------------------------------------------

define 0      := \f x. x
define succ n := \f x. f (n f x)

define recN x f n := n f x

-- general recursion : c -> (n -> c -> c) -> n -> c
define genRecN c g n := snd (recN (pair 0 c) (\p. recP (\k v. pair (succ k) (g k v)) p) n)

define isZero := recN true (\u. false)
define isEven := recN true not
define isOdd  := recN false not

define pred  n := \f x. recN (\u. x) (\g h. h (g f)) n id
define pred2 n := \f x. snd (recN (left x) (\s. case s (\z. right z) (\z. right (f z))) n)

define iterate f n s := recN s f n

define 1 := succ 0
define 2 := succ 1
define 3 := succ 2
define 4 := succ 3
define 5 := succ 4
define 6 := succ 5
define 7 := succ 6
define 8 := succ 7
define 9 := succ 8

define plus n m := recN m succ n
define mult n m := recN 0 (plus m) n
define exp  n m := recN 1 (mult n) m

define fib  n := fst (recN (pair 0 1) (\p. apSnd (plus (snd p)) (swap p)) n)
define fact n := fst (recN (pair 1 1) (\p. ap (mult (snd p)) succ p) n)
define tri  n := genRecN 0 (\k l. plus (succ k) l) n

define div2 n := recN (\b. 0) (\f b. if b (succ (f (not b))) (f (not b))) n false

define showNatBin digits n := \0 1 bin. snd (recN (pair n (if (isEven n) 0 1 bin)) (\p. recP (\k v. (\h. pair h (if (isEven h) (0 v) (1 v))) (div2 k)) p) digits)

define showNatBin' digits n := 
    \0 1 bin. snd 
        (recN
            (pair n (if (isEven n) (\s. s 0) (\s. s 1))) 
            (\p. recP 
                (\k v. 
                    (\h. pair h (if (isEven h) (\s. v (\a. s 0 a)) (\s. v (\a. s 1 a))))
                    (div2 k))
                p)
            (pred digits))
        id




---------------------------------------------------------------------------------------------------
-- Lists                                                                                         --
---------------------------------------------------------------------------------------------------

define empty    := \g e. e
define cons a l := \g e. g a (l g e)

define singleton a := cons a empty

define recL  e g l := l g e
define foldr e g l := l g e

define isEmpty l := recL true (\a b. false) l
define head    l := recL unit (\a xs. a) l
define tail    l := snd (recL (pair id empty) (\a p. pair (cons a) (recP (\f l. f l) p)) l)
define last    l := recL id (\a f. compose f (const a)) l unit
define init    l := recL (\z h. empty) (\a f z h. h z (f a cons)) l unit false

define map    f   := recL empty (\a bs. cons (f a) bs)
define concat u v := recL v cons u
define join   ls  := recL empty concat ls

define prepend x l := concat l (singleton x)

define listNatAsc n := recN (singleton 0) (\xs. cons 0 (map succ xs)) n
define listNatDsc n := recN (singleton 0) (\xs. cons (succ (head xs)) xs) n

define listNatAscBad n := genRecN (singleton n) (\k l. cons (pred (head l)) l) n
define listNatDscBad n := genRecN (singleton 0) (\k l. cons (succ k) l) n




---------------------------------------------------------------------------------------------------
-- Algebraic Lists                                                                               --
---------------------------------------------------------------------------------------------------

define emptyA    := left unit
define consA a l := right (pair a l)

define headA l := case l (\u. emptyA) fst
define tailA l := case l (\u. emptyA) snd

define recAL_kappa := \a l u g. u a (g l u g) u g
define recAL_eta   := \x l u g. case l (\z. x) (\z. z recAL_kappa u g)
define recAL x f l := recAL_eta x l (\a l u g. f a l) (recAL_eta x)

define algListToList l  := recAL empty cons l
define listToAlgList al := recL emptyA consA al

define isEmptyA l := recAL true (\a b. false) l
define headA    l := recAL unit (\a xs. a) l
define tailA    l := snd (recAL (pair id emptyA) (\a p. pair (consA a) (recP (\f l. f l) p)) l)

define sumA l := recAL 0 plus l 
